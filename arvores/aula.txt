Árvore de Busca Binária

Propriedade da árvore de busca binária:
Para todo nó da árvore,
    i -> esq -> chave < i -> chave
    i -> dir -> chave > i -> chave
Como consequência,
todos nós da subárvore enraizada
em i -> esq são menores que i -> chave
e todos os nós da subárvore enraizada
em i -> dir são maiores que i -> chave

class NoABB {
    NoABB* esq;
    NoABB* dir;
    int chave;
    int valor;
};
class ABB {
    NoABB* raiz;
    void inserir(int chave, int valor);
    void buscar(int chave);
    int remover(int chave);
};



Buscar

private:
int buscar(NoABB* n, int chave){
    if(n == nullptr){
        return nullptr;
    }

    if(n->chave == chave){
        return n;
    }
    
    if(chave < n->chave){
        return buscar(n->esq, chave);
        // sei que chave > n->chave
    }return buscar(n->dir, chave);
}

public:
NoABB* buscar(int chave){
    return buscar(this->raiz, chave);
}

inserir

// class ABB(privado)
NoABB* inserir(NoABB* n, int chave, int valor){
    if(n == nullptr){
        return new NoABB(chave, valor);
    }
    if(n->chave == chave){
        n->valor = valor;
    }
    else{
        if(chave < n->chave){
            n->esq = inserir(n->esq, chave, valor);
        }
        else{
            n->dir = inserir(n->dir, chave, valor);
        }
    }
    return n;
}

public:
void inserir(int chave, int valor){
    this->raiz = inserir(this->raiz, chave, valor);
}

Remoção em ABB

Caso 1: o nó a ser removido falho.
Basta fazer o ponteiro que apontava para o 
nó a ser removido aponte para o null. 

Caso 2: o nó a ser removido tem um único filho.
Basta fazer quem apontava para o nó a ser removido, 
passe a apontar para o único filho do nó sendo removido.

Caso 3: remoção de um nó com 2 filhos.
Seja S(n) o nó sucessor de x. Ele pode ser
encontrado percorrendo os ponteiros à esquerda de n.
O algorítimo para remover é:
-> encontrar o nó n a ser removido
-> S = S(n)
-> copiar os dados de s sobre n (não copiar os ponteiros)
-> remover recursivamente S a partir de n -> direita  

Árvores 2-3

Árvore ternaria 
-> até duas chaves por nó
-------------------(m)-------------------
---|----(ej)----|---|----|--(r)---|------
---|(ac)|(h)|(l)|---|----|(p)|(sx)|------
--------------------|--------------------
--------------------|--------------------
Perfeitamente balanceada
-> todos os links null estão na mesma profundidade

Garante altura log₂(n) onde n é o número de chaves da árvore

Inserção
Em qual folha inserir?
2 casos: folha é simples ou dupla?

Caso 1: inserção em nó simples.
-------------------(m)-------------------
---|---(e j)----|---|----|--(r)---|------
---|(ac)|(h)|(l)|---|----|(p)|(sx)|------
--------------⬆-----|--------------------
--------------⬆-----|--------------------
------------k entra aqui-----------------

-------------------(m)-------------------
---|----(e j)----|--|----|--(r)---|------
---|(ac)|(h)|(kl)|--|----|(p)|(sx)|------
--------------⬆-----|--------------------
--------------⬆-----|--------------------
---------token duplo---------------------


Caso 2: inserção em um nó duplo.
Caso 2.1: inserção em um nó duplo raiz.
---------------->----->------------------
----|(re)|------>(res)>--|--(e)--|-------
---------------->---⬆->--|(r)|(s)|-------
---------------->---⬆->----split---------
---------------inserir s-----------------

Caso 2.2: inserir em um nó duplo com pai simples
-------------------(m)-------------------
---|----(e j)---|---|----|--(r)---|------
---|(ac)|(h)|(l)|---|----|(p)|(sx)|------
--------------------|-----------⬆--------
--------------------|-----------⬆--------
-----------------------------z entra-----

-------------------(m)-------------------
---|----(ej)----|---|----|--(r)----|-----
---|(ac)|(h)|(l)|---|----|(p)|(sxz)|-----
--------------------|-----------⬆--------
--------------------|-----------⬆--------
----------------------------subir o x----

-------------------(m)-------------------
---|----(ej)----|---|---|---(rx)----|----
---|(ac)|(h)|(l)|---|---|(p)|(s)|(z)|----
--------------------|---------split------
--------------------|--------------------

Caso 2.3: inserção de um nó duplo com pai duplo.
-------------------(m)-------------------
---|----(ej)----|---|----|--(r)---|------
---|(ac)|(h)|(l)|---|----|(p)|(sx)|------
------⬆-------------|--------------------
------⬆-------------|--------------------
--inserir d------------------------------

-------------------(m)-------------------
--|-----(ej)----|---|----|--(r)---|------
--|(acd)|(h)|(l)|---|----|(p)|(sx)|------
---split------------|--------------------
--------------------|--------------------

-------------------(m)-------------------
-|-----(cej)-----|--|----|--(r)---|------
-|(a)|(d)|(h)|(l)|--|----|(p)|(sx)|------
---split------------|--------------------
--------------------|--------------------

------------------(e m)------------------
-|--(c)--|--(j)--|--|----|--(r)---|------
-|(a)|(d)|(h)|(l)|--|----|(p)|(sx)|------
--------------------|--------------------
--------------------|--------------------


Exercício:
U,T,F,P,R,C,M

-------------(U)->(T U)->(PTU)-----------
--------------------|--------------------
--------------------|--------------------
--------------------|--------------------
--------------------|--------------------
